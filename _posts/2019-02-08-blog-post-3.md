---
title: 'Why We Need An Architecture Pattern'
date: 2019-02-08
permalink: /posts/2019/02/android-clean-architecture
tags:
  -  Android
  -  Clean Architecture
  -  Architecture Pattern
  -  Kotlin
---
Architecture is about intent!

Let's say we have an android app with packages like the following: 


![no architecture image](/images/no_architecture.png)

When I see those packages for the first time I recognize activity, fragment, model.. Etc. Awesome isn’t it?!

But then some questions pop into my head such as:

1. Why the directories of this application expose the framework? Do I even need to know the framework?!

2.  Or why doesn’t the high-level directory of this application tells me what the application actually does?

### Why is the framework in front of me while what the application does is hidden?!
And then I realized that something isn’t right!

## So Why Clean Architecture?

When I heard of the clean architecture for the first time it fascinated me. 

Let's take a look at what it actually does.

![clean architecture image](/images/clean_architecture.jpg)

Following are the main keys of clean architecture:

* Independent of Frameworks: the architecture does not depend on the existence of some library of feature-laden software. This allows you to use such frameworks as tools, rather than having to cram your system into their limited constraints.

* Once you have use-cases layer you can know what the application does without going to the framework. 

* The third key is testability, the business rules can be tested without the framework and I will talk about **How to Write a Testable Code?** later on.


## Understanding Clean Architecture
 
And now let’s dig deep! 

As you know the code is divided into three separate layers:

1. The Presentation Layer: this includes our Framework (ie: Activities, Fragments,...). An activity should be as dumb as possible -never put your business logic in this layer-.

2. The Domain Layer: contains all the use cases of your application. In the following example, we have a ```UseCase``` class that describes what the business needs.
``` kotlin
class GetMenusUseCase {
    fun getAllMenus(pageNo: Int, menusRepository: MenusRepository = MenusRepository()) = menusRepository.getAllMenus(pageNo)
}
```

By that we solve our biggest problem which is **what the application does** by looking to this class, by that we know what should this part of the app does without going to the framework.

3. The Data Layer: this has all the repositories which the domain layer can use. This layer exposes a data source API to outside classes.
``` kotlin
class MenusRepository : MenusDataSource {
    private val remoteDataSource by lazy { MenusRemoteDataSource() }

    override fun getAllMenus(pageNo: Int) = remoteDataSource.getAllMenus(pageNo)
}
```
``` kotlin
interface MenusDataSource {
    fun getAllMenus(pageNo: Int): Call<MenuList>
}
```

In the above example, we can see the repository that is responsible for getting the data from one or multiple data sources by implementing a ```Datasource``` class.

> **The Dependency Rule** of the clean architecture which is the most interesting thing,
> This rule says that source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle.


### Note: You’ll find all the code for this project in the following [Github repo](https://github.com/muhammadFawzy/menus-app-architecture/tree/mvvm-clean).


